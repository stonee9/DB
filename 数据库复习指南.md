
Copyright&copy;[stonee](http://www.stonee.club)

**学习可以带来心灵上的充盈，手机只会带来迷茫和空虚**

约定：
 * 本文是一个对大学数据库知识的一个大概总结，主要用来本人应付考试。
 * 分为三个板块：第一个板块是用来说明各个章节的关系以及都有什么用处；第二个板块是一些必会的概念；第三个板块是考试体型，也可以说是必会的知识点
 * 基于的课本是 《数据库原理教程（第二版）》范明等著

### 课本结构

> 刚学完数据库的时候，一直不知道学这些东西有什么用。理工科凡事都要讲究为什么，既然不知道有什么用，所以在老师上课讲的时候对知识也都是一知半解。在复习的过程中，渐渐懂得了数据库这门课程学的什么东西，所以我列了到思维导图用来帮助大家更好地理解和学习数据库。

![image](https://img-blog.csdnimg.cn/20190527215356250.png)

*汉字数字指的是在第几章，小数字指的是在第几小节*

* 数据库设计并不是说设计一个类似于MySQL的系统，而是类似于存储“学生信息数据库”，大部分工作由DBA来完成
* 在我看来，大学数据库学的就是如何设计好一个数据库，和DBA的关系比较大，而关于数据库本身如何实现的却并没有前者篇幅大。
* SQL可以用来实现完整性，安全性，以及关系的设计，所以放到了第五步
* PS：和数据库系统概念比起来，我们学的这本真的有点小问题。。。。

### 概念

##### 第 1 章 数据库系统概述

* 应用对数据操作的要求：**并发访问、一致性、故障处理、安全性、完整性**
* 数据是数据库中的基本储存对象，数据库是数据的集合
* DBMS的功能：**数据定义(DDL)、数据操作(DML)、事物管理和运行管理、数据存储和查询处理、数据库建立与维护、其他(通信，数据转换等)**
* 数据库系统由**数据库、DBMS(及其开发工具)、应用系统、DBA**组成
* 使用DB管理信息的优点有
  * **数据结构整体化**，数据结构不仅描述显示世界的对象，还描述现实世界的联系
  * **数据共享**，节省空间，防止冗余
  * **数据独立性**，包括物理独立性和逻辑独立性（3级模式，2级映像）
  * **数据由DBMS同一管理，使得系统可以为数据管理提供更多支持(提供事物支持，增强安全性，保持完整性，平衡相互冲突请求，面对故障的弹性)、**
  * **标准化**
* 抽象程度：现实世界——概念模型（一级抽象）——数据模型（二级抽象）
* 数据模型的三要素是**数据结构、数据操作、数据的完整性约束**
* 数据结构是对象和对象间的联系，是对系统的静态描述
* 数据模型可分为**关系模型**，**层次模型**，**网状模型**。课本中主要要讲的是关系模型
* 数据模型用于**数据建模，描述数据的语义、数据之间的联系、数据的操作和数据的完整性约束条件**
* 三级模式：**外模式、模式（逻辑模式）、内模式（存储模式）**
* 二级映像：**外模式-模式、模式-内模式**

#####  第 2 章 实体-联系模型

* **实体**是客观存在且可以相互区分的任何事物，**属性**是实体代表的某种特性，属性的取值范围叫做**值域**
* **实体集**是具有相同属性的实体集合，实体的属性就是实体集的属性
* 唯一能确定实体集中每个实体的**属性**称为**超码**，真子集不是超码的**极小超码**叫做**候选码**，被设计者选定的候选码叫做**主码**，候选码也叫做**码**
* 超码包括候选码，候选码包括超码
* 属性可以分为**多值属性（单值属性）、复合属性（简单属性）、基本属性（派生属性）**，派生属性是由基本属性计算出来的，不存储于数据库中，但要在建E-R图时体现出来
* **联系**是多个实体的相互关联，**联系集**是相同类型联系的集合
* 联系也可以具有属性
* 没有主码的实体集称为**弱实体集**，有主码的称为**强实体集**，通过强实体集（**标识实体集**）确定的弱实体集之间的联系称为**标识性联系**
* E-R图对应的绘制见第三模块考试题型

##### 第 3 章 关系数据模型

* **域**是相同类型值的集合，可以是有限集或者无限集，**元素个数**称为域的**基数**。域和值域不一样
* 关系，笛卡尔积，元组的关系：
  * **关系是笛卡尔积的子集，是元组的集合**
  * 域：A = {a1, a2, a3, ..., am}; 基数= m；
  * 笛卡尔积：A X B X C X ... X N = {(a1, b1, c1, ..., n1), (a2, b2, c2, ..., n2), ...,(am, bm, cm, ..., nm) };
  * 关系：{(a1, b1, c1, ..., n1), (a2, b2, c2, ..., n2)} ; 4元关系（不止一个）
  * 元组：(a1, b1, c1, ..., n1)   4元组 （一共2个）
* **码**中的属性称为**主属性**，否则称为**非主属性**
* 关系模式可表示为**R(U(属性名), D(域), DOM(U-D映射), F(数据依赖集))**，简单记为**R(U)**
* 关系分为**基本关系（实关系，实表）**和**视图（虚关系、虚表）**基本关系是真实存储在数据库中的，视图是查询定义的
* 关系是关系模式的一个实例
* 空值用null表示，是未知的值不能参与运算

##### 第 4 章 SQL

> 约定：()代表必填项；[]代表选填项；/代表或者

* DDL

  ```mysql
  # 创建模式
  create schema (schemaName) [authorization (userName)]
  	[创建模式对象]
  # 删除模式
  drop schema (schemaName) cascade/ restrict
  # 创建模式对象
  create table (tableName)(
      	(columnsName) (数据类型) [default (defaultValue)] [列级约束]
       	[表级约束]);
  # 列级约束分为 not null, primary key, unique, check (boolean)
  # 表约束分为 primary(columns...), unique(columns...), check(boolean), 
  	# 外键约束foreign key(columns...) references (tableName) (primary key)
  
  # 修改表
  alter table (tableName)
  	[add column (columnName) (数据类型) [列级约束]]
  	[alter column (columnName) set/ drop default (defaultValue)]
  	[drop column (columnName)]
  	
  # 插入数据
  insert into tableName values (...);
  ```

* DML

  ```mysql
  select [all/ distinct] (columnName)
  from (tableName) 
  where (条件) 
  group by (columnName)
  having (聚集函数)
  order by (columnName) [asc/ desc]
  
  #where 中包括比较，between，in，like，null，exist，unique 以及他们的反
  
  # like 常用的正则表达有 %, _  
  like 'a\_%' escape '\ '# 定义转义字符
  
  # 连接的表示方法
  natural join 
  tableName join using (columnName)
  
  # 并运算 union 自动去除重复
  # 交运算 intersect [all]
  # 差运算 except [all]	all为了保留重复
  
  # 嵌套子查询
  	# in可以用在嵌套子查询和枚举中
  	# 运算符 (all/some/)
  ```

* 断言

  ```mysql
  # 创建断言
  create assertion (assertionName) check
  	(not exists
      	(sql)
      )
  # 删除断言
  drop assertion (assertionName)
  ```

* 索引

  ```mysql
  create [cluster] index (indexName) on (tableName) (columnName...)
  drop index (indexName)
  ```

* 触发器相关

  ```mysql
  # 创建触发器
  create trigger (TriggerName) before/ after insert/ delete/ update [of 属性] on (table)
  [Reference old/new table/row as newName]# 用来创建过渡变量存放old/new
  [for each row]# 触发器对每一行都有效
  [when (条件)]# 触发条件 是个Boolean值
  begin atomic
  <SQL>
  end
  # 删除触发器
  drop trigger (TriggerName)
  
  # eg
  CREATE TRIGGER InsertionTriggerONSC 
  AFTER INSERT ON SC 
  REFERENCING NEW ROW AS nrow 
  FOR EACH ROW
  WHEN nrow.Sno IN
  	(SELECT Sno
  	 FROM Students
  	 WHERE Dno=‘IE’)
  BEGIN ATOMIC
     INSERT INTO IEGrades
  	SELECT S.Sno, Sname, Cname, Grade
  	FROM Students S, SC, Courses C
  	WHERE S.Sno=nrow.Sno AND C.Cno=nrow.Cno AND S.Sno = SC.Sno AND C.Cno = SC.Cno;
  END
  ```

* 权限相关

  ```mysql 
  # 授予权限
  grant (权限) on (对象) to (用户)
  # 权限包括 select, allprivileges, delete, insert, update 对象是table  
  # 收回权限
  revoke (权限) on (对象) from (用户) restrict/ cascade
  # restrict限制性 cascade级联回收
  ```

* 视图相关

  ```mysql
  # 创建视图
  create view view_1 as 
  	select schame1
  	from table1
  ```

* 角色

  ```mysql
  # 创建角色
  create role roleName
  ```

* 事物

  ```mysql
  # 提交并终止当前事物
  commit [work]:
  # 终止当前事物
  rollback [work]:
  # 设置事物
  set transaction <事物存取模式/隔离级别>
  # 存取模式可以是read only 或者 read write默认后者
  # 隔离级别可以是 read uncommited, read commited, repeatable read, seralizable默认后者
  ```


##### 第 5 章 数据库完整性

* 数据库完整性是指数据**正确性、一致性、相容性**

* 关系的完整性约束分为**实体完整性、参照完整性、用户定义的完整性**

* 实体完整性要求**主码的值必须唯一且不能取空值**；参照完整性要求**某些关系和关系之间的主码会约束**，SQL中的外键即有这层思想；用户自定义完整性要求**对某些属性取值范围的限制**，包括数据类型，单位，缺省值，格式等

* 就约束对象来说，约束可以分为**类型/域约束、属性约束、关系约束、数据库约束**

  <table>
       <tr>
          <td>类型/域约束</td>
          <td>用户自定义完整性</td>
      </tr>
      <tr>
          <td>属性约束</td>
          <td>用户自定义完整性</td>
      </tr>
      <tr>
          <td>关系约束</td>
          <td>实体完整性/用户自定义完整性</td>
      </tr>
          <tr>
          <td>数据库约束</td>
          <td>参照完整性/用户自定义完整性</td>
      </tr>
  </table>

* 从约束状态来说，约束可以分为**静态约束、动态约束**

* DBMS对违约检查需要满足**说明和定义约束的方法、完整性检查、违约处理**

* 实体完整性是关系内的约束，参照完整性是不同关系或者同一关系不同元组的约束

* 违反参照完整性的更新需要：**拒绝（参照关系改动）、级联（被参照关系改动）、置空值（被参照关系改动）、置缺省值（被参照关系改动）**

* 数据库完整性约束可以看做一系列**断言的集合**，如支行的贷款金额必须小于存款金额

* **事件-条件-动作模型**：当某种事件满足某种条件时要进行某种处理办法，这种动作就是**触发器**

##### 第 6 章 数据库安全性

* 数据库安全性是为了**保护数据库，防止未经授权的访问，恶意破坏和修改**
* 数据库系统的主要安全措施包括**用户标识与鉴别、存取控制、视图、审计和数据加密**
* 用户身份认证可通过**使用动态产生的新口令，利用用户唯一性物品，利用用户个人特征**
* **存取控制**是数据库主要的安全措施，可以实现**授权和权限检查**，分为**自主存取控制**和**强制存取控制**
* 自主存取控制(DAC)
  * 通过**授权**实现的
  * DBA对整个数据库存在**绝对控制权**
  * **角色**是一个命名权限的集合，当一组用户具有相同的存取权限的时候，使用角色定义存取权限
  * 被授权者可以复制并传播副本，不安全
* 强制存取控制(MAC)
  * 实体分为**主体和客体**，前者是系统中的活动实体，后者受主体操控
  * MAC机制通过对比客体和主体的**敏感度标记**来确定主体是否能存取客体
  * 仅当主体的许可证级别**大于等于**客体密级时，主体才能读取相应客体
  * 仅当主体的许可证级别**等于**客体密级时，主体才能写相应客体
* 创建视图的用户在视图上所获得的权限**不能超过**他在定义视图基本表示所拥有的权限
* **审计技术**是一种监视技术，会启用一种专门的审计日志

##### 第 7 章 关系数据库设计理论

* 数据依赖和冗余是不可分割的

* 数据依赖分为**函数依赖**和**多值依赖**

* 如果Y属于X，且存在Y函数依赖于X，则称此依赖为**平凡函数依赖**

* **Y完全函数依赖X**是指不存在X的真子集函数决定Y

* 在函数依赖中不存在的属性一定是候选码

* 如果**X->Y**能通过Armstrong公理由**关系模式R的函数依赖集F**导出，则称F**逻辑蕴涵**X->Y，**X->Y的集合**称为**依赖集F**的**闭包**，**Y的集合**称为**属性集X**关于F的**闭包**

* Armstrong公理有**自反律、增广率、传递率**

* 如果两个函数依赖集相等，则称他们**等价**，且**互相覆盖**

* 如果F和G等价，且**F是极小的**，则称F是G的**极小覆盖**，合并F中相同左部函数依赖的右部，得到的函数依赖集称为G的**正则覆盖**

* 极小覆盖的右部都是**单值属性**

* 关系模型的范式：
  <table border="1">
  	<tr>
  		<td>1 NF</td>
  		<td>2 NF</td>
          <td>3 NF</td>
          <td>BCNF</td>
  	</tr>
  	<tr>
  		<td>关系的所有属性值都是原子的，即不存在复合属性和多值属性</td>
  		<td>非主属性完全函数依赖于候选键，即消除了非主属性对候选键的部分依赖</td>
          <td>消除了非主属性对候选键传递依赖</td>
        	<td>非主属性只依赖于候选键</td>
  	</tr>
      <tr>
  		<td>对多值属性进行拆分</td>
  		<td>将关系拆分进而使原来候选键的子集成为候选键</td>
          <td>将关系中同一候选码的划分到一个关系，其余的随便放</td>
        	<td>将关系中同一候选码的划分到一个关系</td>
  	</tr>
  </table>
  
* 平凡的函数依赖和任意属性对超码的依赖一定成立

* 好的分解应当具有**无损连接性**和**依赖保持性**，其中，无损连接性最为重要

* 关系模式R的函数依赖集F在R的属性集U上的**投影**是一个**覆盖**，投影又称为F在U上的**限制**

##### 第 8 章 数据库设计

* 数据库设计就是根据选择的数据库的支撑环境（包括DBMS、操作系统和硬件）和用户信息需求、处理需求，设计出数据模式（包括外模式、概念模式和内模式）以及典型的应用程序，使之能够有效地存储数据

* 数据库设计具有**反复性、试探性、多阶段性和多技术性**的特点
* 两种设计方法：**面向数据**和**面向过程**的设计方法
* 数据库设计步骤：**需求分析、概念结构设计、逻辑结构设计、物理结构设计、数据库运行、数据库实施**
* 数据字典是对**元数据**的描述，通常包括**数据项、数据结构、数据流、数据存储和数据处理过程**五部分
* 数据字典和数据流图一起完整地描述了系统的需求信息
* 概念数据库设计的方法通常有四种：自顶向下、自底向上、逐步扩展和混合策略

##### 第 9 章 查询优化与处理

* 查询处理包括**语法分析与翻译、查询优化和查询执行**
* 查询代价包括**CPU代价、I/O代价和内存代价**，主要是IO开销
* 查询优化分为物理优化和代数优化，优化可以是基于规则，也可以是基于代价的
* 对于简单条件选择的实现，可以使用**线性搜索、二分法搜索和索引**（分为主索引和辅助索引）来处理；对于复杂选择的实现，通过简单选择的交和并来实现
* 连接的基本算法是**嵌套循环**和**块嵌套循环**，对于自然连接和等值连接，可以使用**索引嵌套循环，排序-归并连接和散列连接**等方法
* 语法树查询优化的启发式算法
  * 分解合取选择
  * 选择下移
  * 将笛卡尔积转换为自然连接或者连接
  * 投影下移
  * 合并

##### 第 10 章 事物与并发控制

* 事物特性分为**原子性，一致性，隔离性，持久性**，即**ACID**

* 事物并行或者在运行过程中被强行终止都会破坏ACID

* 事物开始运行就进入**活跃状态**，在最后一条语句执行之后但未被提交处于**部分提交状态**，成功完成后处于**提交状态**，提交之前不能正常执行称为**失败状态**，处于失败状态之后，数据库会消除该事物操作的影响，然后使事物进入**终止状态**，终止状态之后有两种选择，一种是**重启事物**，一种是**杀死事物**

* 隔离级别依次是**read uncommitted, read committed, repeatable read, serializable**

* <table>
       <tr>
          <td>出现的问题</td>
          <td>解决问题的协议</td>
          <td>协议相当于的隔离级别</td>
          <td>协议内容</td>
      </tr>
      <tr>        
          <td>丢失更新</td>
          <td>一级封锁协议</td>
          <td>read uncommitted</td>
          <td><b>更新</b>之前加X锁，事物结束释放</td>
      </tr>
      <tr>
          <td>读脏数据</td>
          <td>二级封锁协议</td>
          <td>read committed</td>
        <td>1级+<b>读取</b>之前加S锁，读完释放</td>
      </tr>
      <tr>
          <td>不可重复读</td>
          <td>三级封锁协议</td>
          <td>repeatable read</td>
          <td>1级+<b>读取</b>之前加S锁，事物结束释放</td>
      </tr>
  </table>
  
* 事物并发执行的理由：**提高吞吐量和资源利用率、减少等待时间**

* 事物并发执行的两种方式：**交叉并发执行、同时并发执行**

* **幻影现象**出现在不可重复读的**删除和插入**中

* **活锁**是指事物因为等待锁而处于无限期等待的状态

* **死锁**是指两个或以上的事物之间循环等待的现象

* 死锁有三种处理方法：预防，检测和解除

* <table>
       <tr>
           <td>预防死锁方法</td>
           <td>缺点1</td>
           <td>缺点2</td>
       </tr>
       <tr>
           <td>一次性封锁法</td>
           <td>降低事物并发度</td>
           <td>提前确定要封锁的数据对象困难</td>
       </tr>
       <tr>
           <td>顺序封锁法</td>
           <td>封锁对象不断变化</td>
           <td>维护封锁顺序困难</td>
       </tr>
   </table>

* 死锁通过**超时法**和**等待图法**检测

* 如果**一组**事物的一个并发调度和一个串行调度执行结果一样，那么称该并发调度是**可串行化的**

* 当一个事物的两种调度结果一样，我们称这两种**调度等价**

* 如果两个在**相同数据**上的操作中至少有一个是**write**指令，则称这两个指令是**冲突的**

* 反复交换不同事物中的**非冲突指令**所得到的调度等价，称为**冲突等价**

* 如果**一个**调度**和串行调度冲突等价**，则称该调度**冲突可串行化**

* **冲突可串行化**一定是**可串行化调度**，其逆**不真**

* **两阶段封锁协议**

   * 扩展阶段：可以申请锁，不能释放
   * 收缩阶段：可以释放，不能申请
   * 意味着申请完后就不能释放锁
   * 扩展阶段**申请最后一个锁的位置**称为**封锁点**

* 两阶段锁协议仍然可能发生死锁

* **严格两阶段封锁协议**：两阶段封锁协议 + 一级封锁协议

* **强两阶段封锁协议**：两阶段封锁协议 + 三级封锁协议

* 多粒度封锁粒度**越大**，数据库能封锁的数据单元就**越少**，并发度**越低**，系统开销**越小**；多粒度封锁粒度**越小**，数据库能封锁的数据单元就**越多**，并发度**越高**，系统开销**越大**

* 意向共享锁，意向排他锁，共享意向排他锁，[参考](https://juejin.im/post/5b85124f5188253010326360)

* 多粒度封锁可以**保证串行化**

##### 第 11 章 数据库恢复技术

* 故障分为**事物故障、系统故障、介质故障**

* 事物故障和系统故障主要通过**日志**来解决，介质故障通过**冗余**来解决

* 日志的内容包括：事务标识符、操作类型、操作对象、旧值和新值；

* 日志记录格式`<Ti, Xj, V1, V2>`

* redo和undo全是**幂等的**

* 日志必须严格按照并发执行的次序登记，必须**先记日志，后写数据库**

* <table>
      <tr>
      	<td>基于日志的恢复技术</td>
      	<td>描述</td>
      	<td>事物故障恢复</td>
      	<td>系统故障恢复</td>
      </tr>    
      <tr>
      	<td>延时更新技术</td>
      	<td>事物提交之后再对数据库更新，不需要记录V1</td>
      	<td>清除日志记录，重新启动事物</td>
      	<td>未完成事物清除日志记录，完成事物redo</td>
      </tr>  
      <tr>
      	<td>基于日志的恢复技术</td>
      	<td>事物更新之后就写入数据库，需要记录V2</td>
      	<td>undo</td>
      	<td>未完成事物undo，完成事物redo</td>
      </tr>  
  </table>

* 系统故障时难以确定某些在日志中commit的事物未完成数据库中的更新，恢复效率很慢，所以引进了**基于检查点的恢复技术**

* 检查点定期：

  * 将所有留在主存中的日志记录强制输出到稳定存储器中
  * 将所有修改的缓冲块输出到磁盘上
  * 将一个日志记录<checkpoint, L>强制输出到稳定存储器中，此时停止事物执行的任何动作

* 海量转储：整个数据库副本；增量转储：部分数据库副本

* 静态转储：不允许事物运行；动态转储：和事物并行执行

* 影子分页技术的优点和缺点

  * 影子分页技术节省了基本日志的读写操作开销，并且不需要undo和redo操作，加快了数据库恢复速度，比基于日志的恢复技术所需要的磁盘操作少。
  * 影子分页技术推广到多个事务并发执行的情况有困难、需要复杂的物理存储管理机制、当页表很大时，建立和存取页表的开销将会很大。基于日志的恢复机制不存在这些问题。

### 考试题型

* 选择，填空，判断，简答，
* 画E-R图，将E-R图转换为关系模式并给出主码和函数依赖关系
  * 属性用椭圆表示，多值属性用双椭圆表示，派生属性用虚表椭圆表示，主属性下要有下划线
  * 强实体集用实线矩形表示，弱实体集用虚线矩形表示，他们之间的标示性联系用双边菱形表示
  * 联系集用菱形表示
  * 多对一时，多的一方不带箭头，一的一方带箭头，多的一方完全对应一则多的一方用双实线；多对多时，两边都有箭头
  * 转换时，派生属性忽略、复合属性展平、为多值属性重新创建关系，主码为自身的属性和所在的实体或者关系的主码
  * 弱实体集的属性包括标识实体集的码，弱实体集的分辨属性和实体集的码构成新建关系的码
  * 联系用关系表示，依赖联系忽略。该关系中的属性包含了两边实体的主码。如果一对一，则每个实体集的码都是关系的码；如果一对多，多的实体集的码组成关系的码；如果多对多，则所有实体集均为关系的码；如果关系具有相同的码，则合并
* 用关系代数进行查询
  * 基本运算：选择、投影、并、差、笛卡尔积
  * 附加运算：交、除、连接、自然连接
  * 扩展运算：广义投影运算、聚集函数与分组聚集、外连接
* 用SQL进行DDL和DML
* 用SQL来完成授权，写一个触发器
* 求候选码

  * 不在FD出现的属性，必须包含在候选码中
  * 不在FD右部出现的属性，必须包含在候选码中
  * 只在FD左边出现，必须包含在候选码中
  * 能唯一标识元组的属性或属性组，就是候选码
  * 外部属性一定存在于任何候选码当中
  * 只在FD右部出现的属性，不属于候选码
  * 只有左部或者左部＋不出现部一定是唯一候选码
* 求属性集或者是依赖集的闭包
  
  * 将属性集通过Armstrong公理求一遍即可得到闭包
* 求函数依赖集的极小覆盖和正则覆盖
  * 先将右部不是单个属性的分解
  * 先去掉左边的冗余关系：去掉左边的假设冗余属性，如果仍然可以推出其闭包（闭包中包含该冗余属性），则删除
  * 再去掉F中冗余的函数依赖：删除一个假设冗余的函数依赖，如果仍然可以推出其闭包，则删除
  * 再将能通过Armstrong公理推导的删除即为极小覆盖
  * 将相同左部函数依赖的右部合并，即为正则覆盖 
* 判定关系模式属于哪个范式
* 检测无损连接分解
  * 行为分解后的关系模式，列为属性
  * 如果属性属于关系，则把属性与关系的交界的值设为a，下标为属性的列，否则设为b，下标的属性的行和列
  * 再看依赖关系，如A->C，那么C列的值的相等个数设成和A的相等个数一样并一一对应，C中如果有a则设为a，没有随意设
  * 如果出现一行全是a的，则为无损连接分解
* 检测函数依赖分解
* 分解出具有无损连接性的BCNF
  
  *   设U=ABCDE, F={ A→B,B→C,CD→B},求R(U,F)的无损连接的BCNF分解。
      *   F已是最小函数依赖集Fmin。
      *   ADE不在右边出现，(ADE)+=ADEBC=U，所以ADE是R的唯一的码，A→B不合BCNF要求，分解R：R1(AB, A→B), R2(ACDE, A→C))。
      *   R1是BCNF，但R2中A→C不合BCNF要求，分解R2：R3 (AC, A→C), R4(ADE, ф))，R3、R4都是BCNF。
      *   得到R的无损连接的BCNF分解ρ={R1(AB, A→B), R3(AC, A→C),R4(ADE, ф)} 
* 分解出具有无损连接性和函数依赖性的3NF
  
  * 先求出候选码
  * 再求出函数依赖集F的正则覆盖
  * 设U=ABCDE, F={AB→C,A→B,D→BC,C→B},求R(U,F)的保持函数依赖且无损连接的3NF分解
    * 求出唯以候选码为ADE
    * 求出正则覆盖为(A→C, D→C, C→B)
    * 将A→C赋给re，因为DC不在re中，把DC也赋该re，因为CB不在re中，把CB也赋给re
    * 又因为re中不包含候选码ADE，所以把ADE也放进去
    * 答案为ρ={R1(AC, A→C),R2(DC,D→C),R3(CB,C→B), R4(ADE,ф)}、
* 求正确并行调度的可能执行结果
* 求n个事物的可串行化/不可串行化的调度
* 语法树查询优化的启发式算法
  * 分解合取选择
  * 选择下移
  * 将笛卡尔积转换为自然连接或者连接
  * 投影下移
  * 合并

### 备注

* 考试之前持续补充
* 大家一起修改，可以上传例题之类的福泽整个备考学子hhhh



